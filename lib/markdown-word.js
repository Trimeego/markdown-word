// Generated by CoffeeScript 1.3.1
(function() {
  var XML, addRelationship, buildDocument, documentAttrs, documentSectionProps, fs, http, https, markdown, processChildElements, processMarkdownObject, relationships, temp, templatePath, url, walk, zip,
    __slice = [].slice,
    _this = this;

  markdown = require("markdown").markdown;

  fs = require("fs-extra");

  temp = require("temp");

  zip = require("node-native-zip");

  XML = require("xml");

  http = require("http");

  https = require("https");

  url = require("url");

  documentAttrs = {
    "xmlns:wpc": "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
    "xmlns:mo": "http://schemas.microsoft.com/office/mac/office/2008/main",
    "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
    "xmlns:mv": "urn:schemas-microsoft-com:mac:vml",
    "xmlns:o": "urn:schemas-microsoft-com:office:office",
    "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
    "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
    "xmlns:v": "urn:schemas-microsoft-com:vml",
    "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
    "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
    "xmlns:w10": "urn:schemas-microsoft-com:office:word",
    "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
    "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
    "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
    "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
    "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
    "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
    "mc:Ignorable": "w14 wp14"
  };

  documentSectionProps = {
    "w:sectPr": [
      {
        "w:pgSz": {
          _attr: {
            "w:w": "12240",
            "w:h": "15840"
          }
        }
      }, {
        "w:pgMar": {
          _attr: {
            "w:top": "1440",
            "w:right": "1800",
            "w:bottom": "1440",
            "w:left": "1800",
            "w:header": "720",
            "w:footer": "720",
            "w:gutter": "0"
          }
        }
      }, {
        "w:cols": {
          _attr: {
            "w:space": "720"
          }
        }
      }, {
        "w:docGrid": {
          _attr: {
            "w:linePitch": "360"
          }
        }
      }
    ]
  };

  relationships = {
    "Relationships": [
      {
        _attr: {
          "xmlns": "http://schemas.openxmlformats.org/package/2006/relationships"
        }
      }, {
        "Relationship": [
          {
            _attr: {
              "Id": "rId1",
              "Type": "http://schemas.openxmlformats.org/officeDocument/2006/relationships/numbering",
              "Target": "numbering.xml"
            }
          }
        ]
      }, {
        "Relationship": [
          {
            _attr: {
              "Id": "rId2",
              "Type": "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
              "Target": "styles.xml"
            }
          }
        ]
      }, {
        "Relationship": [
          {
            _attr: {
              "Id": "rId3",
              "Type": "http://schemas.microsoft.com/office/2007/relationships/stylesWithEffects",
              "Target": "stylesWithEffects.xml"
            }
          }
        ]
      }, {
        "Relationship": [
          {
            _attr: {
              "Id": "rId4",
              "Type": "http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings",
              "Target": "settings.xml"
            }
          }
        ]
      }, {
        "Relationship": [
          {
            _attr: {
              "Id": "rId5",
              "Type": "http://schemas.openxmlformats.org/officeDocument/2006/relationships/webSettings",
              "Target": "webSettings.xml"
            }
          }
        ]
      }, {
        "Relationship": [
          {
            _attr: {
              "Id": "rId6",
              "Type": "http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable",
              "Target": "fontTable.xml"
            }
          }
        ]
      }, {
        "Relationship": [
          {
            _attr: {
              "Id": "rId7",
              "Type": "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
              "Target": "theme/theme1.xml"
            }
          }
        ]
      }
    ]
  };

  addRelationship = function(link) {
    var relId;
    relId = "rId" + (relationships["Relationships"].length + 1);
    relationships["Relationships"].push({
      "Relationship": [
        {
          _attr: {
            "Id": relId,
            "Type": "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
            "Target": link,
            "TargetMode": "External"
          }
        }
      ]
    });
    return relId;
  };

  processChildElements = function(list, children, levelOffset) {
    var el, objectResults, r, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      el = list[_i];
      objectResults = processMarkdownObject(el, levelOffset);
      if (Object.prototype.toString.call(objectResults) === '[object Array]') {
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (_j = 0, _len1 = objectResults.length; _j < _len1; _j++) {
            r = objectResults[_j];
            _results1.push(children.push(r));
          }
          return _results1;
        })());
      } else {
        _results.push(children.push(objectResults));
      }
    }
    return _results;
  };

  processMarkdownObject = function(object, levelOffset) {
    var attributes, childElements, children, count, el, elements, href, itemElements, itemType, l, level, lines, objectType, out, rid, title, _i, _j, _k, _len, _len1, _len2;
    children = [];
    if (Object.prototype.toString.call(object) === '[object Array]') {
      objectType = object[0], elements = 2 <= object.length ? __slice.call(object, 1) : [];
    } else {
      objectType = "text";
      elements = object;
    }
    switch (objectType) {
      case "markdown":
        processChildElements(elements, children, levelOffset);
        children.push(documentSectionProps);
        out = {
          "w:document": [
            {
              _attr: documentAttrs
            }, {
              "w:body": children
            }
          ]
        };
        break;
      case "header":
        attributes = elements[0], childElements = 2 <= elements.length ? __slice.call(elements, 1) : [];
        level = Number(attributes.level) + levelOffset;
        children.push({
          "w:pPr": [
            {
              "w:pStyle": [
                {
                  _attr: {
                    "w:val": "Heading" + level
                  }
                }
              ]
            }
          ]
        });
        processChildElements(childElements, children);
        out = {
          "w:p": children
        };
        break;
      case "para":
        processChildElements(elements, children);
        out = {
          "w:p": children
        };
        break;
      case "bulletlist":
        out = [];
        count = 0;
        for (_i = 0, _len = elements.length; _i < _len; _i++) {
          el = elements[_i];
          count++;
          children = [
            {
              "w:pPr": [
                {
                  "w:pStyle": {
                    _attr: {
                      "w:val": "ListParagraph"
                    }
                  }
                }, {
                  "w:numPr": [
                    {
                      "w:ilvl": {
                        _attr: {
                          "w:val": "0"
                        }
                      }
                    }, {
                      "w:numId": {
                        _attr: {
                          "w:val": "2"
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ];
          itemType = el[0], itemElements = 2 <= el.length ? __slice.call(el, 1) : [];
          processChildElements(itemElements, children);
          out.push({
            "w:p": children
          });
        }
        break;
      case "numberlist":
        out = [];
        count = 0;
        for (_j = 0, _len1 = elements.length; _j < _len1; _j++) {
          el = elements[_j];
          count++;
          children = [
            {
              "w:pPr": [
                {
                  "w:pStyle": {
                    _attr: {
                      "w:val": "ListParagraph"
                    }
                  }
                }, {
                  "w:numPr": [
                    {
                      "w:ilvl": {
                        _attr: {
                          "w:val": "0"
                        }
                      }
                    }, {
                      "w:numId": {
                        _attr: {
                          "w:val": "1"
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ];
          itemType = el[0], itemElements = 2 <= el.length ? __slice.call(el, 1) : [];
          processChildElements(itemElements, children);
          out.push({
            "w:p": children
          });
        }
        break;
      case "strong":
        children.push({
          "w:rPr": [
            {
              "w:b": ""
            }
          ]
        });
        processChildElements(elements, children);
        out = {
          "w:r": children
        };
        break;
      case "inlinecode":
        out = {
          "w:r": [
            {
              "w:t": [
                {
                  _attr: {
                    "xml:space": "preserve"
                  }
                }, " "
              ]
            }, {
              "w:rPr": [
                {
                  "w:rFonts": [
                    {
                      _attr: {
                        "w:ascii": "Courier New",
                        "w:hAnsi": "Courier New",
                        "w:cs": "Courier New"
                      }
                    }
                  ]
                }, {
                  "w:sz": [
                    {
                      _attr: {
                        "w:val": "20"
                      }
                    }
                  ]
                }, {
                  "w:szCs": [
                    {
                      _attr: {
                        "w:val": "20"
                      }
                    }
                  ]
                }
              ]
            }, {
              "w:t": [
                {
                  _attr: {
                    "xml:space": "preserve"
                  }
                }, elements[0]
              ]
            }
          ]
        };
        break;
      case "code_line":
        out = {
          "w:p": [
            {
              "w:pPr": [
                {
                  "w:pStyle": [
                    {
                      _attr: {
                        "w:val": "CodeBlock"
                      }
                    }
                  ]
                }
              ]
            }, {
              "w:r": [
                {
                  "w:t": [
                    {
                      _attr: {
                        "xml:space": "preserve"
                      }
                    }, elements[0]
                  ]
                }
              ]
            }
          ]
        };
        break;
      case "code_block":
        out = [
          {
            "w:p": ""
          }
        ];
        lines = elements[0].split("\n");
        for (_k = 0, _len2 = lines.length; _k < _len2; _k++) {
          l = lines[_k];
          out.push(processMarkdownObject(["code_line", l], levelOffset));
        }
        out.push({
          "w:p": ""
        });
        break;
      case "link":
        href = elements[0].href;
        rid = addRelationship(href);
        title = elements[1];
        out = [
          {
            "w:r": [
              {
                "w:t": [
                  {
                    _attr: {
                      "xml:space": "preserve"
                    }
                  }, " "
                ]
              }
            ]
          }, {
            "w:hyperlink": [
              {
                _attr: {
                  "r:id": rid,
                  "w:history": "1"
                }
              }, {
                "w:r": [
                  {
                    "w:rPr": [
                      {
                        "w:rStyle": [
                          {
                            _attr: {
                              "w:val": "Hyperlink"
                            }
                          }
                        ]
                      }, {
                        "w:t": [title]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ];
        break;
      case "img":
        out = {
          "w:r": [
            {
              "w:t": "<<< " + objectType + " not yet implemented>>>"
            }
          ]
        };
        break;
      case "text":
        out = {
          "w:r": [
            {
              "w:t": elements
            }
          ]
        };
        break;
      default:
        out = {
          "w:r": [
            {
              "w:t": "<<< " + objectType + " not yet implemented>>>"
            }
          ]
        };
    }
    return out;
  };

  walk = function(dir, done) {
    var results;
    results = [];
    return fs.readdir(dir, function(err, list) {
      var pending;
      if (err) {
        return done(err);
      }
      pending = list.length;
      if (!pending) {
        return done(null, results);
      }
      return list.forEach(function(file) {
        file = dir + "/" + file;
        return fs.stat(file, function(err, stat) {
          if (stat && stat.isDirectory()) {
            return walk(file, function(err, res) {
              results = results.concat(res);
              if (!--pending) {
                return done(null, results);
              }
            });
          } else {
            results.push(file);
            if (!--pending) {
              return done(null, results);
            }
          }
        });
      });
    });
  };

  templatePath = __dirname + "/template";

  buildDocument = function(inputMarkdown, outputFile, levelOffset) {
    var document, documentXML, info, markdownJSON, relationshipsXML;
    if (!outputFile) {
      info = temp.openSync("md2word");
      outputFile = info.path;
    }
    markdownJSON = markdown.parse(inputMarkdown);
    document = processMarkdownObject(markdownJSON, levelOffset);
    documentXML = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n" + (XML(document));
    relationshipsXML = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n" + (XML(relationships));
    walk(templatePath, function(err, files) {
      var archive, file, targetFiles, _i, _len;
      targetFiles = [];
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        if (file.indexOf(".DS_Store") === -1) {
          targetFiles.push({
            name: file.replace("" + templatePath + "/", ""),
            path: file,
            compression: 'store'
          });
        }
      }
      archive = new zip();
      return temp.open("md2word", function(err, info) {
        fs.write(info.fd, new Buffer(documentXML, "utf8").toString());
        return fs.close(info.fd, function(err) {
          targetFiles.push({
            name: "word/document.xml",
            path: info.path,
            compression: 'store'
          });
          return temp.open("md2word", function(err, info) {
            fs.write(info.fd, new Buffer(relationshipsXML, "utf8").toString());
            return fs.close(info.fd, function(err) {
              targetFiles.push({
                name: "word/_rels/document.xml.rels",
                path: info.path,
                compression: 'store'
              });
              return archive.addFiles(targetFiles, function(err) {
                var buff;
                if (err) {
                  return console.log("err while adding files", err);
                } else {
                  return buff = archive.toBuffer(function(result) {
                    return fs.writeFile(outputFile, result, function() {});
                  });
                }
              });
            });
          });
        });
      });
    });
    return outputFile;
  };

  module.exports = {
    fromFile: function(filepath, outputFile, callback, levelOffset) {
      if (levelOffset == null) {
        levelOffset = 0;
      }
      return fs.readFile(filepath, function(err, data) {
        var out;
        if (err) {
          throw err;
        }
        out = buildDocument(data, outputFile, levelOffset);
        return callback(null, out);
      });
    },
    fromMarkdown: function(inputMarkdown, outputFile, callback, levelOffset) {
      var out;
      if (levelOffset == null) {
        levelOffset = 0;
      }
      out = buildDocument(inputMarkdown, outputFile, levelOffset);
      return callback(null, out);
    },
    fromUrl: function(fileUrl, outputFile, callback, levelOffset) {
      var inputMarkdown, lib, options, port;
      if (levelOffset == null) {
        levelOffset = 0;
      }
      inputMarkdown = "";
      if (fileUrl.split(":")[0] === "https") {
        port = 443;
        lib = https;
      } else {
        port = 80;
        lib = http;
      }
      options = {
        host: url.parse(fileUrl).host,
        port: port,
        path: url.parse(fileUrl).pathname
      };
      return lib.get(options, function(res) {
        res.on('data', function(data) {
          return inputMarkdown += data;
        });
        return res.on('end', function() {
          var out;
          out = buildDocument(inputMarkdown, outputFile, levelOffset);
          return callback(null, out);
        });
      });
    }
  };

}).call(this);

// Generated by CoffeeScript 1.3.3
(function() {
  var XML, addRelationships, buildDocumentFromFragments, buildDocumentFromMarkdown, buildDocumentObjectFromFragments, counter, createUid, documentAttrs, documentSectionProps, fs, http, https, id, markdown, markdownFromFile, markdownFromUrl, millisOld, path, processChildElements, processMarkdownObject, relationships, resolvePath, temp, templatePath, url, walk, zip,
    __slice = [].slice,
    _this = this;

  markdown = require("markdown").markdown;

  fs = require("fs-extra");

  path = require("path");

  temp = require("temp");

  zip = require("./zip/janzip.js");

  XML = require("xml");

  http = require("http");

  https = require("https");

  url = require("url");

  documentAttrs = {
    "xmlns:wpc": "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
    "xmlns:mo": "http://schemas.microsoft.com/office/mac/office/2008/main",
    "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
    "xmlns:mv": "urn:schemas-microsoft-com:mac:vml",
    "xmlns:o": "urn:schemas-microsoft-com:office:office",
    "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
    "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
    "xmlns:v": "urn:schemas-microsoft-com:vml",
    "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
    "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
    "xmlns:w10": "urn:schemas-microsoft-com:office:word",
    "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
    "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
    "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
    "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
    "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
    "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
    "mc:Ignorable": "w14 wp14"
  };

  documentSectionProps = {
    "w:sectPr": [
      {
        "w:pgSz": {
          _attr: {
            "w:w": "12240",
            "w:h": "15840"
          }
        }
      }, {
        "w:pgMar": {
          _attr: {
            "w:top": "1440",
            "w:right": "1800",
            "w:bottom": "1440",
            "w:left": "1800",
            "w:header": "720",
            "w:footer": "720",
            "w:gutter": "0"
          }
        }
      }, {
        "w:cols": {
          _attr: {
            "w:space": "720"
          }
        }
      }, {
        "w:docGrid": {
          _attr: {
            "w:linePitch": "360"
          }
        }
      }
    ]
  };

  relationships = {
    "Relationships": [
      {
        _attr: {
          "xmlns": "http://schemas.openxmlformats.org/package/2006/relationships"
        }
      }, {
        "Relationship": [
          {
            _attr: {
              "Id": "rId1",
              "Type": "http://schemas.openxmlformats.org/officeDocument/2006/relationships/numbering",
              "Target": "numbering.xml"
            }
          }
        ]
      }, {
        "Relationship": [
          {
            _attr: {
              "Id": "rId2",
              "Type": "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
              "Target": "styles.xml"
            }
          }
        ]
      }, {
        "Relationship": [
          {
            _attr: {
              "Id": "rId3",
              "Type": "http://schemas.microsoft.com/office/2007/relationships/stylesWithEffects",
              "Target": "stylesWithEffects.xml"
            }
          }
        ]
      }, {
        "Relationship": [
          {
            _attr: {
              "Id": "rId4",
              "Type": "http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings",
              "Target": "settings.xml"
            }
          }
        ]
      }, {
        "Relationship": [
          {
            _attr: {
              "Id": "rId5",
              "Type": "http://schemas.openxmlformats.org/officeDocument/2006/relationships/webSettings",
              "Target": "webSettings.xml"
            }
          }
        ]
      }, {
        "Relationship": [
          {
            _attr: {
              "Id": "rId6",
              "Type": "http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable",
              "Target": "fontTable.xml"
            }
          }
        ]
      }, {
        "Relationship": [
          {
            _attr: {
              "Id": "rId7",
              "Type": "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
              "Target": "theme/theme1.xml"
            }
          }
        ]
      }
    ]
  };

  millisOld = 0;

  counter = 0;

  id = 1;

  resolvePath = function(from, to) {
    var out, toUrl;
    out = {
      type: "absolute",
      path: to
    };
    if (from) {
      if (from.href) {
        toUrl = url.parse(to);
        if (!toUrl.host) {
          out = {
            type: "relative",
            path: url(from, to)
          };
        }
      } else {
        if (to.indexOf(".") === 0) {
          out = {
            type: "relative",
            path: path.resolve(from, to)
          };
        }
      }
    }
    return out;
  };

  createUid = function() {
    var id2, millis, protectRollover, uid;
    protectRollover = false;
    millis = new Date().getTime() - 1262304000000 * Math.pow(2, 12);
    id2 = id * Math.pow(2, 8);
    return uid = Math.abs(millis + id2 + counter + Math.round(Math.random(10) * 100));
  };

  addRelationships = function(rels) {
    var rel, relAttribs, _i, _len;
    for (_i = 0, _len = rels.length; _i < _len; _i++) {
      rel = rels[_i];
      if (rel) {
        relAttribs = {
          "Id": rel.relId,
          "Type": rel.type,
          "Target": rel.href
        };
        if (rel.targetMode) {
          relAttribs["TargetMode"] = rel.targetMode;
        }
        relationships["Relationships"].push({
          "Relationship": [
            {
              _attr: relAttribs
            }
          ]
        });
      }
    }
    return relationships;
  };

  processChildElements = function(list, children, levelOffset, rels, rootPath) {
    var el, objectResults, r, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      el = list[_i];
      objectResults = processMarkdownObject(el, levelOffset);
      if (Object.prototype.toString.call(objectResults) === '[object Array]') {
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (_j = 0, _len1 = objectResults.length; _j < _len1; _j++) {
            r = objectResults[_j];
            if (Object.prototype.toString.call(r.markup) === '[object Array]') {
              Array.prototype.push.apply(children, r.markup);
            } else {
              children.push(r.markup);
            }
            _results1.push(Array.prototype.push.apply(rels, r.relationships));
          }
          return _results1;
        })());
      } else {
        if (Object.prototype.toString.call(objectResults.markup) === '[object Array]') {
          Array.prototype.push.apply(children, objectResults.markup);
        } else {
          children.push(objectResults.markup);
        }
        _results.push(Array.prototype.push.apply(rels, objectResults.relationships));
      }
    }
    return _results;
  };

  processMarkdownObject = function(object, levelOffset, rootPath) {
    var attributes, childElements, children, count, el, elements, fragments, href, itemElements, itemType, l, level, lines, objectType, out, r, rels, rid, rp, title, _i, _j, _k, _len, _len1, _len2;
    children = [];
    rels = [];
    if (Object.prototype.toString.call(object) === '[object Array]') {
      objectType = object[0], elements = 2 <= object.length ? __slice.call(object, 1) : [];
    } else {
      objectType = "text";
      elements = object;
    }
    switch (objectType) {
      case "markdown":
        fragments = [];
        processChildElements(elements, fragments, levelOffset, rels, rootPath);
        out = fragments;
        break;
      case "header":
        attributes = elements[0], childElements = 2 <= elements.length ? __slice.call(elements, 1) : [];
        level = Number(attributes.level) + levelOffset;
        children.push({
          "w:pPr": [
            {
              "w:pStyle": [
                {
                  _attr: {
                    "w:val": "Heading" + level
                  }
                }
              ]
            }
          ]
        });
        processChildElements(childElements, children, levelOffset, rels, rootPath);
        out = {
          "w:p": children
        };
        break;
      case "para":
        processChildElements(elements, children, levelOffset, rels, rootPath);
        out = {
          "w:p": children
        };
        break;
      case "bulletlist":
        out = [];
        count = 0;
        for (_i = 0, _len = elements.length; _i < _len; _i++) {
          el = elements[_i];
          count++;
          children = [
            {
              "w:pPr": [
                {
                  "w:pStyle": {
                    _attr: {
                      "w:val": "ListParagraph"
                    }
                  }
                }, {
                  "w:numPr": [
                    {
                      "w:ilvl": {
                        _attr: {
                          "w:val": "0"
                        }
                      }
                    }, {
                      "w:numId": {
                        _attr: {
                          "w:val": "2"
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ];
          itemType = el[0], itemElements = 2 <= el.length ? __slice.call(el, 1) : [];
          processChildElements(itemElements, children, levelOffset, rels, rootPath);
          out.push({
            "w:p": children
          });
        }
        break;
      case "numberlist":
        rid = createUid();
        out = [];
        count = 0;
        for (_j = 0, _len1 = elements.length; _j < _len1; _j++) {
          el = elements[_j];
          count++;
          children = [
            {
              "w:pPr": [
                {
                  "w:pStyle": [
                    {
                      _attr: {
                        "w:val": "ListParagraph"
                      }
                    }
                  ]
                }, {
                  "w:numPr": [
                    {
                      "w:ilvl": {
                        _attr: {
                          "w:val": "0"
                        }
                      }
                    }, {
                      "w:numId": {
                        _attr: {
                          "w:val": "" + rid
                        }
                      }
                    }
                  ]
                }, {
                  "w:ind": {
                    _attr: {
                      "w:left": "720",
                      "w:hanging": "360"
                    }
                  }
                }
              ]
            }
          ];
          itemType = el[0], itemElements = 2 <= el.length ? __slice.call(el, 1) : [];
          processChildElements(itemElements, children, levelOffset, rels, rootPath);
          out.push({
            "w:p": children
          });
        }
        break;
      case "strong":
        children.push({
          "w:rPr": [
            {
              "w:b": ""
            }
          ]
        });
        processChildElements(elements, children, levelOffset, rels, rootPath);
        children.push({
          "w:r": [
            {
              "w:t": [
                {
                  _attr: {
                    "xml:space": "preserve"
                  }
                }, " "
              ]
            }
          ]
        });
        out = {
          "w:r": children
        };
        break;
      case "em":
        children.push({
          "w:rPr": [
            {
              "w:i": ""
            }
          ]
        });
        processChildElements(elements, children, levelOffset, rels, rootPath);
        children.push({
          "w:r": [
            {
              "w:t": [
                {
                  _attr: {
                    "xml:space": "preserve"
                  }
                }, " "
              ]
            }
          ]
        });
        out = {
          "w:r": children
        };
        break;
      case "inlinecode":
        out = {
          "w:r": [
            {
              "w:t": [
                {
                  _attr: {
                    "xml:space": "preserve"
                  }
                }, " "
              ]
            }, {
              "w:rPr": [
                {
                  "w:rFonts": [
                    {
                      _attr: {
                        "w:ascii": "Courier New",
                        "w:hAnsi": "Courier New",
                        "w:cs": "Courier New"
                      }
                    }
                  ]
                }, {
                  "w:sz": [
                    {
                      _attr: {
                        "w:val": "20"
                      }
                    }
                  ]
                }, {
                  "w:szCs": [
                    {
                      _attr: {
                        "w:val": "20"
                      }
                    }
                  ]
                }
              ]
            }, {
              "w:t": [
                {
                  _attr: {
                    "xml:space": "preserve"
                  }
                }, elements[0]
              ]
            }
          ]
        };
        break;
      case "code_block":
        out = [
          {
            "w:p": ""
          }
        ];
        lines = elements[0].split("\n");
        for (_k = 0, _len2 = lines.length; _k < _len2; _k++) {
          l = lines[_k];
          out.push({
            "w:p": [
              {
                "w:pPr": [
                  {
                    "w:pStyle": [
                      {
                        _attr: {
                          "w:val": "CodeBlock"
                        }
                      }
                    ]
                  }
                ]
              }, {
                "w:r": [
                  {
                    "w:t": [
                      {
                        _attr: {
                          "xml:space": "preserve"
                        }
                      }, l
                    ]
                  }
                ]
              }
            ]
          });
        }
        out.push({
          "w:p": ""
        });
        break;
      case "link":
        rp = resolvePath(rootPath, elements[0].href);
        href = rp.path;
        rid = "rId" + createUid();
        title = elements[1];
        rels.push({
          href: href,
          rid: rid,
          title: title,
          type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
          targetMode: "External"
        });
        out = [
          {
            "w:r": [
              {
                "w:t": [
                  {
                    _attr: {
                      "xml:space": "preserve"
                    }
                  }, " "
                ]
              }
            ]
          }, {
            "w:hyperlink": [
              {
                _attr: {
                  "r:id": rid,
                  "w:history": "1"
                }
              }, {
                "w:r": [
                  {
                    "w:rPr": [
                      {
                        "w:rStyle": [
                          {
                            _attr: {
                              "w:val": "Hyperlink"
                            }
                          }
                        ]
                      }, {
                        "w:t": [title]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ];
        break;
      case "img":
        rid = "rId" + createUid();
        rels.push({
          href: elements[0].href,
          rid: rid,
          type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image"
        });
        out = [
          {
            "w:pict": [
              {
                "v:shape": [
                  {
                    "v:imagedata": [
                      {
                        _attr: {
                          "r:id": rid
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ];
        break;
      case "text":
        out = {
          "w:r": [
            {
              "w:t": elements
            }
          ]
        };
        break;
      default:
        out = {
          "w:r": [
            {
              "w:t": "<<< " + objectType + " not yet implemented>>>"
            }
          ]
        };
    }
    return r = {
      markup: out,
      relationships: rels
    };
  };

  walk = function(dir, done) {
    var results;
    results = [];
    return fs.readdir(dir, function(err, list) {
      var pending;
      if (err) {
        return done(err);
      }
      pending = list.length;
      if (!pending) {
        return done(null, results);
      }
      return list.forEach(function(file) {
        file = dir + "/" + file;
        return fs.stat(file, function(err, stat) {
          if (stat && stat.isDirectory()) {
            return walk(file, function(err, res) {
              results = results.concat(res);
              if (!--pending) {
                return done(null, results);
              }
            });
          } else {
            results.push(file);
            if (!--pending) {
              return done(null, results);
            }
          }
        });
      });
    });
  };

  templatePath = __dirname + "/template";

  buildDocumentObjectFromFragments = function(fragments) {
    var docObjFragments, docRelationships, fragment, out, r, _i, _j, _len, _len1;
    docObjFragments = [];
    docRelationships = [];
    if (fragments.markup) {
      Array.prototype.push.apply(docObjFragments, fragments.markup);
      if (fragments.relationships) {
        Array.prototype.push.apply(docRelationships, fragments.relationships);
      }
    } else {
      for (_i = 0, _len = fragments.length; _i < _len; _i++) {
        fragment = fragments[_i];
        Array.prototype.push.apply(docObjFragments, fragment.markup);
        Array.prototype.push.apply(docRelationships, fragment.relationships);
      }
    }
    for (_j = 0, _len1 = docRelationships.length; _j < _len1; _j++) {
      r = docRelationships[_j];
      relationships["Relationships"].push({
        "Relationship": [
          {
            _attr: {
              "Id": r.rid,
              "Type": r.type,
              "Target": r.href,
              "TargetMode": r.targetMode
            }
          }
        ]
      });
    }
    out = {
      relationships: relationships,
      markup: {
        "w:document": [
          {
            _attr: documentAttrs
          }, {
            "w:body": docObjFragments
          }
        ]
      }
    };
    return out;
  };

  buildDocumentFromFragments = function(fragments, outputFile) {
    var document, documentXML, image, imageCount, relationshipsXML, targetFiles, _i, _len, _ref;
    targetFiles = [];
    document = buildDocumentObjectFromFragments(fragments);
    documentXML = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n" + (XML(document.markup));
    relationshipsXML = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n" + (XML(addRelationships(document.relationships)));
    imageCount = 0;
    _ref = document.relationships;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      image = _ref[_i];
      if (!(image.type === "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image")) {
        continue;
      }
      imageCount++;
      targetFiles.push({
        name: "word/media/" + imageCount,
        path: image.href,
        compression: 'store'
      });
    }
    walk(templatePath, function(err, files) {
      var archive, file, _j, _len1;
      for (_j = 0, _len1 = files.length; _j < _len1; _j++) {
        file = files[_j];
        if (file.indexOf(".DS_Store") === -1) {
          targetFiles.push({
            name: file.replace("" + templatePath + "/", ""),
            path: file,
            compression: 'store'
          });
        }
      }
      archive = new zip();
      return temp.open("md2word", function(err, info) {
        fs.write(info.fd, new Buffer(documentXML, "utf8").toString());
        return fs.close(info.fd, function(err) {
          targetFiles.push({
            name: "word/document.xml",
            path: info.path,
            compression: 'store'
          });
          return temp.open("md2word", function(err, info) {
            fs.write(info.fd, new Buffer(relationshipsXML, "utf8").toString());
            return fs.close(info.fd, function(err) {
              targetFiles.push({
                name: "word/_rels/document.xml.rels",
                path: info.path,
                compression: 'store'
              });
              return archive.addFiles(targetFiles, function(err) {
                var buff;
                if (err) {
                  return console.log("err while adding files", err);
                } else {
                  return buff = archive.toBuffer(function(result) {
                    return fs.writeFile(outputFile, result, function() {});
                  });
                }
              });
            });
          });
        });
      });
    });
    return outputFile;
  };

  buildDocumentFromMarkdown = function(inputMarkdown, outputFile, levelOffset, rootPath) {
    var fragments, info, markdownJSON;
    if (!outputFile) {
      info = temp.openSync("md2word");
      outputFile = info.path;
    }
    markdownJSON = markdown.parse(inputMarkdown);
    fragments = processMarkdownObject(markdownJSON, levelOffset, rootPath);
    return buildDocumentFromFragments(fragments, outputFile, levelOffset, rootPath);
  };

  markdownFromFile = function(filepath, callback) {
    return fs.readFile(filepath, function(err, data) {
      return callback(err, data);
    });
  };

  markdownFromUrl = function(fileUrl, callback) {
    var inputMarkdown, lib, options, port;
    inputMarkdown = "";
    if (fileUrl.split(":")[0] === "https") {
      port = 443;
      lib = https;
    } else {
      port = 80;
      lib = http;
    }
    options = {
      host: url.parse(fileUrl).host,
      port: port,
      path: url.parse(fileUrl).pathname
    };
    return lib.get(options, function(res) {
      res.on('data', function(data) {
        return inputMarkdown += data;
      });
      return res.on('end', function() {
        return callback(null, inputMarkdown);
      });
    });
  };

  module.exports = {
    documentFromFile: function(filepath, outputFile, callback, levelOffset) {
      var rootPath;
      if (levelOffset == null) {
        levelOffset = 0;
      }
      rootPath = path.dirname(path.resolve(filepath));
      return markdownFromFile(filepath, function(err, data) {
        var out;
        out = buildDocumentFromMarkdown(data, outputFile, levelOffset, rootPath);
        return callback(null, out);
      });
    },
    documentFromMarkdown: function(inputMarkdown, outputFile, callback, levelOffset, rootPath) {
      var out;
      if (levelOffset == null) {
        levelOffset = 0;
      }
      if (rootPath == null) {
        rootPath = null;
      }
      out = buildDocumentFromMarkdown(inputMarkdown, outputFile, levelOffset, rootPath);
      return callback(null, out);
    },
    documentFromUrl: function(fileUrl, outputFile, callback, levelOffset) {
      var rootPath;
      if (levelOffset == null) {
        levelOffset = 0;
      }
      rootPath = url.parse(fileUrl);
      return markdownFromUrl(fileUrl, function(err, data) {
        var out;
        out = buildDocumentFromMarkdown(data, outputFile, levelOffset, rootPath);
        return callback(null, out);
      });
    },
    documentFromFragments: function(fragments, outputFile, callback) {
      var out;
      out = buildDocumentFromFragments(fragments, outputFile);
      return callback(null, out);
    },
    fragmentsFromFile: function(filepath, callback, levelOffset) {
      var rootPath;
      if (levelOffset == null) {
        levelOffset = 0;
      }
      rootPath = path.dirname(path.resolve(filepath));
      return markdownFromFile(filepath, function(err, data) {
        var fragments, markdownJSON;
        markdownJSON = markdown.parse(data);
        fragments = processMarkdownObject(markdownJSON, levelOffset, rootPath);
        return callback(null, fragments);
      });
    },
    fragmentsFromMarkdown: function(inputMarkdown, callback, levelOffset, rootPath) {
      var fragments, markdownJSON;
      if (levelOffset == null) {
        levelOffset = 0;
      }
      if (rootPath == null) {
        rootPath = null;
      }
      markdownJSON = markdown.parse(inputMarkdown);
      fragments = processMarkdownObject(markdownJSON, levelOffset, rootPath);
      return callback(null, fragments);
    },
    fragmentsFromUrl: function(fileUrl, callback, levelOffset, rootPath) {
      rootPath = url.parse(fileUrl);
      return markdownFromUrl(fileUrl, function(err, data) {
        var fragments, markdownJSON;
        markdownJSON = markdown.parse(data);
        fragments = processMarkdownObject(markdownJSON, levelOffset, rootPath);
        return callback(null, fragments);
      });
    }
  };

}).call(this);
